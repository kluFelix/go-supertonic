Directory structure:
└── supertonic-go/
    ├── flake.nix
    ├── main.go
    └── .envrc

================================================
FILE: flake.nix
================================================
{
  description = "A basic flake with a shell";
  inputs.nixpkgs.url = "github:NixOS/nixpkgs/nixpkgs-unstable";
  inputs.systems.url = "github:nix-systems/default";
  inputs.flake-utils = {
    url = "github:numtide/flake-utils";
    inputs.systems.follows = "systems";
  };

  outputs =
    { nixpkgs, flake-utils, ... }:
    flake-utils.lib.eachDefaultSystem (
      system:
      let
        pkgs = nixpkgs.legacyPackages.${system};
      in
      {
        devShells.default = pkgs.mkShell {
          packages = with pkgs; [
            bashInteractive # necessary?

            go
          ];
        };
      }
    );
}




================================================
FILE: main.go
================================================
package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"strings"

	"github.com/gin-gonic/gin"
	ort "github.com/yalue/onnxruntime_go"
)

// OpenAI-compatible request structure
type TTSRequest struct {
	Model          string  `json:"model" binding:"required"`
	Input          string  `json:"input" binding:"required"`
	Voice          string  `json:"voice" binding:"required"`
	ResponseFormat string  `json:"response_format,omitempty"` // "wav", "mp3", etc.
	Speed          float64 `json:"speed,omitempty"`
}

// OpenAI-compatible response (for JSON mode)
type TTSResponse struct {
	AudioData []byte `json:"audio_data"` // Base64 encoded
}

// Server configuration
type ServerConfig struct {
	Host           string
	Port           int
	OnnxDir        string
	VoiceStylesDir string
	DefaultVoice   string
	DefaultModel   string
	TotalSteps     int
	Speed          float32
	CacheEnabled   bool
}

var (
	ttsEngine *TextToSpeech
	config    *ServerConfig
	voiceMap  map[string]string // Maps voice names to JSON files
)

func init() {
	// Default voices mapping
	voiceMap = map[string]string{
		"alloy":  "M1.json",
		"echo":   "M2.json",
		"fable":  "M3.json",
		"onyx":   "M4.json",
		"nova":   "M5.json",
		"shimmer": "F1.json",
		"alice":  "F2.json",
		"bella":  "F3.json",
		"clara":  "F4.json",
		"diana":  "F5.json",
	}
}

func main() {
	// Parse command-line flags
	cfg := &ServerConfig{}
	flag.StringVar(&cfg.Host, "host", "0.0.0.0", "Server host")
	flag.IntVar(&cfg.Port, "port", 8080, "Server port")
	flag.StringVar(&cfg.OnnxDir, "onnx-dir", "assets/onnx", "Path to ONNX model directory")
	flag.StringVar(&cfg.VoiceStylesDir, "voice-styles-dir", "assets/voice_styles", "Path to voice styles directory")
	flag.StringVar(&cfg.DefaultVoice, "default-voice", "alloy", "Default voice")
	flag.StringVar(&cfg.DefaultModel, "default-model", "supertonic", "Default model name")
	flag.IntVar(&cfg.TotalSteps, "total-steps", 5, "Number of denoising steps")
	flag.Float64Var(&cfg.Speed, "speed", 1.05, "Speech speed factor")
	flag.BoolVar(&cfg.CacheEnabled, "cache-enabled", true, "Enable voice style caching")
	flag.Parse()

	config = cfg

	// Initialize ONNX Runtime
	if err := InitializeONNXRuntime(); err != nil {
		log.Fatalf("Failed to initialize ONNX Runtime: %v", err)
	}
	defer ort.DestroyEnvironment()

	// Load config
	modelCfg, err := LoadCfgs(cfg.OnnxDir)
	if err != nil {
		log.Fatalf("Failed to load model config: %v", err)
	}

	// Initialize TTS engine
	ttsEngine, err = LoadTextToSpeech(cfg.OnnxDir, false, modelCfg)
	if err != nil {
		log.Fatalf("Failed to load TTS engine: %v", err)
	}
	defer ttsEngine.Destroy()

	log.Printf("Supertonic TTS API server starting on %s:%d", cfg.Host, cfg.Port)
	log.Printf("Voice styles directory: %s", cfg.VoiceStylesDir)
	log.Printf("Available voices: %v", getAvailableVoices())

	// Setup HTTP server
	r := setupRouter()

	addr := fmt.Sprintf("%s:%d", cfg.Host, cfg.Port)
	if err := r.Run(addr); err != nil {
		log.Fatalf("Server failed to start: %v", err)
	}
}

func setupRouter() *gin.Engine {
	r := gin.Default()

	// Health check
	r.GET("/health", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{
			"status": "healthy",
			"model":  config.DefaultModel,
		})
	})

	// OpenAI-compatible TTS endpoint
	r.POST("/v1/audio/speech", handleTTSSpeech)

	// List available voices
	r.GET("/v1/voices", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{
			"voices": getAvailableVoices(),
		})
	})

	return r
}

func getAvailableVoices() []string {
	voices := make([]string, 0, len(voiceMap))
	for voice := range voiceMap {
		voices = append(voices, voice)
	}
	return voices
}

func handleTTSSpeech(c *gin.Context) {
	var req TTSRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Validate input
	if req.Input == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Input text cannot be empty"})
		return
	}

	// Use default voice if not specified
	if req.Voice == "" {
		req.Voice = config.DefaultVoice
	}

	// Validate and map voice
	voiceFile, ok := voiceMap[req.Voice]
	if !ok {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": fmt.Sprintf("Invalid voice. Available voices: %v", getAvailableVoices()),
		})
		return
	}

	// Use default speed if not specified
	if req.Speed == 0 {
		req.Speed = float64(config.Speed)
	}

	// Load voice style
	voicePath := filepath.Join(config.VoiceStylesDir, voiceFile)
	style, err := LoadVoiceStyle([]string{voicePath}, false)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("Failed to load voice: %v", err)})
		return
	}
	defer style.Destroy()

	// Generate speech
	lang := detectLanguage(req.Input)
	wavData, duration, err := ttsEngine.Call(req.Input, lang, style, config.TotalSteps, float32(req.Speed), 0.3)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("TTS generation failed: %v", err)})
		return
	}

	// Convert to WAV bytes
	wavLen := int(float32(ttsEngine.SampleRate) * duration)
	wavBytes, err := encodeWAV(wavData[:wavLen], ttsEngine.SampleRate)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("Failed to encode audio: %v", err)})
		return
	}

	// Determine response format
	format := req.ResponseFormat
	if format == "" {
		format = "wav"
	}

	switch format {
	case "wav":
		c.Data(http.StatusOK, "audio/wav", wavBytes)
	case "json":
		// Base64 encode for JSON response
		resp := TTSResponse{
			AudioData: wavBytes,
		}
		c.JSON(http.StatusOK, resp)
	default:
		c.JSON(http.StatusBadRequest, gin.H{"error": "Unsupported response format"})
	}
}

func detectLanguage(text string) string {
	// Simple language detection - you can enhance this
	// For now, default to English
	return "en"
}

func encodeWAV(audioData []float32, sampleRate int) ([]byte, error) {
	// Create temporary file for wav encoder
	tmpFile, err := os.CreateTemp("", "supertonic-*.wav")
	if err != nil {
		return nil, err
	}
	defer os.Remove(tmpFile.Name())
	defer tmpFile.Close()

	// Convert float32 to int
	intData := make([]int, len(audioData))
	for i, sample := range audioData {
		// Clamp to [-1, 1]
		if sample > 1.0 {
			sample = 1.0
		} else if sample < -1.0 {
			sample = -1.0
		}
		intData[i] = int(sample * 32767)
	}

	// Write WAV file
	// This is a simplified version - you'd want to use a proper WAV library
	// For now, return raw PCM data (you can enhance this)
	
	// In a real implementation, use a proper WAV encoder
	return createMinimalWAV(intData, sampleRate), nil
}

func createMinimalWAV(audioData []int, sampleRate int) []byte {
	// Simplified WAV header creation
	// In production, use a proper library like github.com/go-audio/wav
	dataSize := len(audioData) * 2
	fileSize := 36 + dataSize

	wav := make([]byte, 44+dataSize)

	// RIFF header
	copy(wav[0:4], []byte("RIFF"))
	// File size
	wav[4] = byte(fileSize)
	wav[5] = byte(fileSize >> 8)
	wav[6] = byte(fileSize >> 16)
	wav[7] = byte(fileSize >> 24)
	copy(wav[8:12], []byte("WAVE"))

	// fmt subchunk
	copy(wav[12:16], []byte("fmt "))
	wav[16] = 16 // Subchunk size
	wav[20] = 1  // Audio format (PCM)
	wav[21] = 0
	wav[22] = 1  // Num channels
	wav[23] = 0
	// Sample rate
	wav[24] = byte(sampleRate)
	wav[25] = byte(sampleRate >> 8)
	wav[26] = byte(sampleRate >> 16)
	wav[27] = byte(sampleRate >> 24)
	// Byte rate
	byteRate := sampleRate * 2
	wav[28] = byte(byteRate)
	wav[29] = byte(byteRate >> 8)
	wav[30] = byte(byteRate >> 16)
	wav[31] = byte(byteRate >> 24)
	wav[32] = 2  // Block align
	wav[33] = 0
	wav[34] = 16 // Bits per sample
	wav[35] = 0

	// data subchunk
	copy(wav[36:40], []byte("data"))
	// Data size
	wav[40] = byte(dataSize)
	wav[41] = byte(dataSize >> 8)
	wav[42] = byte(dataSize >> 16)
	wav[43] = byte(dataSize >> 24)

	// Audio data
	for i, sample := range audioData {
		idx := 44 + i*2
		wav[idx] = byte(sample)
		wav[idx+1] = byte(sample >> 8)
	}

	return wav
}



================================================
FILE: .envrc
================================================
# shellcheck shell=bash
if ! has nix_direnv_version || ! nix_direnv_version 3.1.0; then
  source_url "https://raw.githubusercontent.com/nix-community/nix-direnv/3.1.0/direnvrc" "sha256-yMJ2OVMzrFaDPn7q8nCBZFRYpL/f0RcHzhmw/i6btJM="
fi
use flake



